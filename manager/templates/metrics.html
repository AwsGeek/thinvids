{% extends "base.html" %}
{% block title %}Network Traffic – Thinvids{% endblock %}
{% block head_extra %}
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <style>
    th.sortable { cursor: pointer; user-select: none; }
    .sort-indicator { display:inline-block; width:0.8rem; }
  </style>
{% endblock %}

{% block content %}
  <div class="space-y-4">
    <div class="flex items-center justify-between">
      <h1 class="text-2xl font-bold">Network Traffic</h1>
      <div class="flex items-center gap-2">
        <label class="text-sm text-gray-700">Window:</label>
        <select id="window-min" class="border rounded px-2 py-1 text-sm">
          <option value="1">1 min</option>
          <option value="5" selected>5 min</option>
          <option value="10">10 min</option>
          <option value="15">15 min</option>
          <option value="30">30 min</option>
        </select>

        <label for="host-select" class="text-sm text-gray-700 ml-2">Host:</label>
        <select id="host-select" class="border rounded px-2 py-1 text-sm min-w-[12rem]">
          <option value="__ALL__" selected>All hosts</option>
        </select>
      </div>
    </div>

    <div class="bg-white rounded shadow p-4">
      <div class="flex items-baseline justify-between mb-2">
        <h2 class="font-semibold">Per-Host Throughput</h2>
        <span id="last-updated" class="text-xs text-gray-600"></span>
      </div>
      <div class="w-full h-72"><canvas id="hostChart" class="w-full h-full"></canvas></div>
      <p class="text-xs text-gray-600 mt-2">
        Each host has two lines: RX (solid) and TX (dashed). Values are Mbps (8 × bytes/sec ÷ 1e6).
        The time window is fixed to the selected duration; early portions with no data are shown as gaps.
      </p>
    </div>

    <div class="bg-white rounded shadow p-4">
      <div class="flex items-baseline justify-between mb-2">
        <h2 class="font-semibold">Top Talkers (latest sample)</h2>
        <button id="refresh-now" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm">Refresh</button>
      </div>
      <div class="overflow-x-auto">
        <table class="min-w-full border-collapse">
          <thead>
            <tr class="bg-gray-100 text-left text-sm">
              <th class="px-2 py-1 sortable" data-key="hostname">Host <span class="sort-indicator"></span></th>
              <th class="px-2 py-1 sortable" data-key="rx">RX (Mbps) <span class="sort-indicator"></span></th>
              <th class="px-2 py-1 sortable" data-key="tx">TX (Mbps) <span class="sort-indicator"></span></th>
              <th class="px-2 py-1 sortable" data-key="cpu">CPU% <span class="sort-indicator"></span></th>
              <th class="px-2 py-1 sortable" data-key="gpu">GPU% <span class="sort-indicator"></span></th>
              <th class="px-2 py-1 sortable" data-key="mem">Mem% <span class="sort-indicator"></span></th>
              <th class="px-2 py-1 sortable" data-key="disk">Disk% <span class="sort-indicator"></span></th>
              <th class="px-2 py-1 sortable" data-key="ts">Last Seen <span class="sort-indicator"></span></th>
            </tr>
          </thead>
          <tbody id="talkers"></tbody>
        </table>
      </div>
    </div>
  </div>
{% endblock %}

{% block scripts %}
<script>
  // --------- helpers ---------
  const updatedEl   = document.getElementById('last-updated');
  const windowSel   = document.getElementById('window-min');
  const hostSel     = document.getElementById('host-select');
  const talkersBody = document.getElementById('talkers');

  const nowSec = () => Math.floor(Date.now() / 1000);
  const mbps   = bps => (Number(bps || 0) * 8 / 1e6);

  // --------- chart setup ---------
  const PALETTE = [
    '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
    '#8c564b', '#e377c2', '#17becf', '#7f7f7f', '#bcbd22',
    '#000000', '#ff1493', '#00ced1', '#ffa500', '#4169e1',
    '#2e8b57', '#ff4500', '#6a5acd', '#008080', '#c71585'
  ];
  const lighten = (hex, amt = 0.38) => {
    const m = hex.match(/^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i); if (!m) return hex;
    let [r,g,b] = [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16)];
    r = Math.round(r + (255-r)*amt); g = Math.round(g + (255-g)*amt); b = Math.round(b + (255-b)*amt);
    return '#' + [r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
  };

  let frameSeconds = []; // used to show minute ticks only
  const ctx = document.getElementById('hostChart').getContext('2d');
  const hostChart = new Chart(ctx, {
    type: 'line',
    data: { labels: [], datasets: [] },
    options: {
      responsive: true, maintainAspectRatio: false, animation: false,
      plugins: { legend: { display: false }, tooltip: { mode: 'index', intersect: false } },
      interaction: { mode: 'index', intersect: false },
      elements: { point: { radius: 0 } },
      scales: {
        x: {
          grid: { display: false },
          ticks: {
            autoSkip: false,
            callback: (idx) => {
              const ts = frameSeconds[idx] || 0;
              if ((ts % 60) !== 0) return '';
              const d = new Date(ts * 1000);
              return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }
          }
        },
        y: {
          beginAtZero: true,
          min: 0,
          max: 1000,
          ticks: { stepSize: 500, callback: v => v.toLocaleString() },
          title: { display: true, text: 'Mbps' }
        }
      }
    }
  });

  // stable host order → stable colors
  const hostOrder = [];
  function sortHosts(hosts) {
    return [...hosts].sort((a,b) => {
      const na = parseInt((a||'').match(/\d+/)?.[0] || 0, 10);
      const nb = parseInt((b||'').match(/\d+/)?.[0] || 0, 10);
      return na - nb || a.localeCompare(b);
    });
  }

  function ensureHostSelectOptions(hosts) {
    const current = hostSel.value || '__ALL__';
    const opts = ['__ALL__', ...hosts];
    hostSel.innerHTML = '';
    for (const v of opts) {
      const op = document.createElement('option');
      op.value = v;
      op.textContent = v === '__ALL__' ? 'All hosts' : v;
      hostSel.appendChild(op);
    }
    hostSel.value = opts.includes(current) ? current : '__ALL__';
  }

  // Build fixed window frame (N seconds ending "now") and map cache values onto it.
  function buildFrameFromCache(cache, N) {
    const endTs = nowSec();
    const frame = Array.from({length: N}, (_, i) => endTs - (N - 1 - i));
    const tsIdx = new Map(cache.labels.map((t, i) => [t, i]));
    const hosts = Object.keys(cache.hosts || {});
    const seriesByHost = {};
    hosts.forEach(h => {
      const rx = new Array(N).fill(null);
      const tx = new Array(N).fill(null);
      for (let k = 0; k < N; k++) {
        const idx = tsIdx.get(frame[k]);
        if (idx != null) {
          rx[k] = cache.hosts[h].rx[idx];
          tx[k] = cache.hosts[h].tx[idx];
        }
      }
      seriesByHost[h] = { rx, tx };
    });
    return { frame, seriesByHost };
  }

  function renderChart(cache) {
    const N = (parseInt(windowSel.value, 10) || 5) * 60;
    const { frame, seriesByHost } = buildFrameFromCache(cache, N);
    frameSeconds = frame;
    hostChart.data.labels = frame;

    const allHosts = sortHosts(Object.keys(seriesByHost));
    ensureHostSelectOptions(allHosts);

    const selected = hostSel.value || '__ALL__';
    const showHosts = selected === '__ALL__' ? allHosts : [selected];

    const datasets = [];
    showHosts.forEach((h) => {
      if (!hostOrder.includes(h)) hostOrder.push(h);
      const baseColor = PALETTE[hostOrder.indexOf(h) % PALETTE.length];
      datasets.push({
        label: `${h} RX`,
        data: seriesByHost[h]?.rx || new Array(N).fill(null),
        borderColor: baseColor, fill: false, tension: 0.12, borderWidth: 2, spanGaps: true
      });
      datasets.push({
        label: `${h} TX`,
        data: seriesByHost[h]?.tx || new Array(N).fill(null),
        borderColor: lighten(baseColor, 0.38), borderDash: [6,4], fill: false, tension: 0.12, borderWidth: 2, spanGaps: true
      });
    });

    hostChart.data.datasets = datasets;
    hostChart.update('none');
  }

  // ---------- Top Talkers sortable table ----------
  const SORT_LS_KEY = 'metrics_talkers_sort_v1';
  let sortState = loadSortState();
  let currentNodes = [];

  function loadSortState() {
    try {
      const d = JSON.parse(localStorage.getItem(SORT_LS_KEY) || '{}');
      if (d && d.key && d.dir) return d;
    } catch {}
    return { key: 'throughput', dir: 'desc' };
  }
  function saveSortState() {
    try { localStorage.setItem(SORT_LS_KEY, JSON.stringify(sortState)); } catch {}
  }
  function naturalHostCompare(a, b) {
    const num = s => {
      const m = String(s||'').match(/(\d+)/);
      return m ? parseInt(m[1], 10) : Number.MAX_SAFE_INTEGER;
    };
    const na = num(a), nb = num(b);
    if (na !== nb) return na - nb;
    const sa = String(a||'').toLowerCase();
    const sb = String(b||'').toLowerCase();
    return sa < sb ? -1 : sa > sb ? 1 : 0;
  }
  function sortValue(n, key) {
    switch (key) {
      case 'hostname': return n.hostname || '';
      case 'rx': return Number(n.rx_bps || 0);
      case 'tx': return Number(n.tx_bps || 0);
      case 'cpu': return Number(n.cpu || 0);
      case 'gpu': return Number(n.gpu || 0);
      case 'mem': return Number(n.mem || 0);
      case 'disk': return Number(n.disk || 0);
      case 'ts': return Number(n.ts || 0);
      case 'throughput': return Math.max(Number(n.rx_bps || 0), Number(n.tx_bps || 0));
      default: return 0;
    }
  }
  function renderTalkers(nodes) {
    currentNodes = Array.isArray(nodes) ? nodes.slice() : [];

    const key = sortState.key;
    const dirMul = sortState.dir === 'asc' ? 1 : -1;

    const rows = currentNodes.sort((a,b) => {
      if (key === 'hostname') {
        return naturalHostCompare(a.hostname, b.hostname) * dirMul;
      }
      const va = sortValue(a, key), vb = sortValue(b, key);
      const na = Number(va), nb = Number(vb);
      if (!Number.isNaN(na) && !Number.isNaN(nb)) {
        return (na - nb) * dirMul;
      }
      const sa = String(va).toLowerCase(), sb = String(vb).toLowerCase();
      return (sa < sb ? -1 : sa > sb ? 1 : 0) * dirMul;
    }).slice(0, 20);

    talkersBody.innerHTML = '';
    for (const n of rows) {
      const tr = document.createElement('tr');
      tr.className = 'border-b';
      tr.innerHTML = `
        <td class="px-2 py-1 font-mono">${n.hostname || ''}</td>
        <td class="px-2 py-1">${mbps(n.rx_bps).toFixed(2)}</td>
        <td class="px-2 py-1">${mbps(n.tx_bps).toFixed(2)}</td>
        <td class="px-2 py-1">${Number(n.cpu||0).toFixed(1)}</td>
        <td class="px-2 py-1">${Number(n.gpu||0).toFixed(1)}</td>
        <td class="px-2 py-1">${Number(n.mem||0).toFixed(1)}</td>
        <td class="px-2 py-1">${Number(n.disk||0).toFixed(1)}</td>
        <td class="px-2 py-1">${n.ts ? new Date(n.ts*1000).toLocaleTimeString() : ''}</td>
      `;
      talkersBody.appendChild(tr);
    }
    updateHeaderSortIndicators();
  }

  function updateHeaderSortIndicators() {
    document.querySelectorAll('thead th.sortable').forEach(th => {
      const span = th.querySelector('.sort-indicator');
      if (!span) return;
      const k = th.dataset.key;
      if (k === sortState.key) {
        span.textContent = sortState.dir === 'asc' ? '▲' : '▼';
        th.classList.add('text-blue-700');
      } else {
        span.textContent = '';
        th.classList.remove('text-blue-700');
      }
    });
  }

  function bindSortHandlers() {
    document.querySelectorAll('thead th.sortable').forEach(th => {
      th.addEventListener('click', () => {
        const k = th.dataset.key;
        if (!k) return;
        if (sortState.key === k) {
          sortState.dir = (sortState.dir === 'asc') ? 'desc' : 'asc';
        } else {
          sortState.key = k;
          sortState.dir = (k === 'hostname') ? 'asc' : 'desc';
        }
        saveSortState();
        renderTalkers(currentNodes);
      });
    });
  }

  async function fetchSnapshot() {
    const r = await fetch('/metrics_snapshot');
    if (!r.ok) return null;
    return r.json();
  }

  async function tick() {
    try {
      const payload = await fetchSnapshot();

      if (payload && Array.isArray(payload.nodes)) {
        const sample = {};
        payload.nodes.forEach(n => {
          if (!n.hostname) return;
          sample[n.hostname] = { rx: mbps(n.rx_bps || 0), tx: mbps(n.tx_bps || 0) };
        });
        const cache = window.NETCACHE.push(nowSec(), sample);
        renderChart(cache);

        updatedEl.textContent = `Updated: ${new Date().toLocaleTimeString()}`;
        const nodes = (payload.nodes || []).map(n => ({
          hostname: n.hostname, ts: n.ts, cpu: n.cpu, gpu: n.gpu, mem: n.mem, disk: n.disk,
          rx_bps: Number(n.rx_bps || 0), tx_bps: Number(n.tx_bps || 0)
        }));
        renderTalkers(nodes);
      } else {
        renderChart(window.NETCACHE.load());
      }
    } catch {
      renderChart(window.NETCACHE.load());
    }
  }

  document.getElementById('refresh-now').addEventListener('click', tick);
  windowSel.addEventListener('change', () => renderChart(window.NETCACHE.load()));
  hostSel.addEventListener('change',  () => renderChart(window.NETCACHE.load()));

  bindSortHandlers();
  updateHeaderSortIndicators();
  renderChart(window.NETCACHE.load());
  tick();
  setInterval(tick, 1000);
</script>
{% endblock %}
